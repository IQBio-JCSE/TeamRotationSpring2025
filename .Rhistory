# Installation ----------------------------------------------------------------
# To run simulations with the SUNFLO crop model and this R package, two
# softwares (VLE & R) and two packages (sunflo & rsunflo) need to be installed.
# install the VLE simulation platform : VLE project github or website
# and RVLE R package github
# install the SUNFLO crop model for VLE simulation platform : RECORD project
# model library
if (!requireNamespace("devtools", quietly = TRUE)) {
install.packages("devtools")
}
install.packages("rvle")
# install the VLE simulation platform (if not already installed)
if (!requireNamespace("rvle", quietly = TRUE)) {
devtools::install_github("picasa/rvle") # install the RVLE package from github
}
library(data.table) # data manipulation
library(ggplot2) # plotting
library(parallel)  # parallelization
# Initialize parameters
num_wild_population <- 100
num_domesticated_population <- 100
time_steps <- 0
# Initialize plant population
initialize_population <- function() {
# Create wild population
wild_population <- data.table(
trait = rnorm(num_wild_population, mean = 0.55, sd = 0.3),  # Gaussian distribution
growth_rate = NA,
reproduction_rate = NA,
resistance = NA,
size = 1,
group = "Wild Population"
)
# Ensure trait value within [0, 1] for wild population
wild_population[trait < 0, trait := 0]
wild_population[trait > 1, trait := 1]
# Create domesticated population
domesticated_population <- data.table(
trait = rnorm(num_domesticated_population, mean = 0.4, sd = 0.02),  # Narrow Gaussian distribution
growth_rate = NA,
reproduction_rate = NA,
resistance = NA,
size = 1,
group = "Domesticated Population"
)
# Ensure trait value within [0, 1] for domesticated population
domesticated_population[trait < 0, trait := 0]
domesticated_population[trait > 1, trait := 1]
# Combine populations
population <- rbind(wild_population, domesticated_population)
# Initialize plant properties
population[, growth_rate := 1 - trait]
population[, reproduction_rate := 1 - trait]
population[, resistance := trait]
return(population)
}
# Grow function
grow <- function(population) {
population[, size := size + growth_rate * 0.1]
return(population)
}
# Reproduce function
reproduce <- function(population) {
# Calculate number of offspring for each individual plant
reproduction_prob <- population$reproduction_rate * 0.05
num_offspring <- floor(reproduction_prob) # Ensure integer
# Create new plants based on reproduction probability
new_plants <- population[rep(1:.N, num_offspring)]
if (nrow(new_plants) > 0) {
new_plants[, size := 1]
new_plants[, growth_rate := 1 - trait]
new_plants[, reproduction_rate := 1 - trait]
new_plants[, resistance := trait]
population <- rbind(population, new_plants)
}
return(population)
}
# mortality function
suffer_mortality <- function(population, pest_pressure) {
mortality_prob <- pest_pressure * (1 - population$resistance) * 0.1
survivors <- population[runif(.N) >= mortality_prob]
return(survivors)
}
plot_population <- function(population, time_step, results) {
wild_population_count <- nrow(population[group == "Wild Population"])
domesticated_population_count <- nrow(population[group == "Domesticated Population"])
wild_avg_trait <- mean(population[group == "Wild Population", trait])
domesticated_avg_trait <- mean(population[group == "Domesticated Population", trait])
wild_trait_variance <- var(population[group == "Wild Population", trait])
domesticated_trait_variance <- var(population[group == "Domesticated Population", trait])
# Calculate bounds for variance
wild_upper_bound <- wild_avg_trait + sqrt(wild_trait_variance)
wild_lower_bound <- wild_avg_trait - sqrt(wild_trait_variance)
domesticated_upper_bound <- domesticated_avg_trait + sqrt(domesticated_trait_variance)
domesticated_lower_bound <- domesticated_avg_trait - sqrt(domesticated_trait_variance)
# Append results to the tracking data.table
results <- rbind(results, data.table(
time = time_step,
group = "Wild Population",
count = wild_population_count,
avg_trait = wild_avg_trait,
trait_variance = wild_trait_variance,
upper_bound = wild_upper_bound,
lower_bound = wild_lower_bound
))
results <- rbind(results, data.table(
time = time_step,
group = "Domesticated Population",
count = domesticated_population_count,
avg_trait = domesticated_avg_trait,
trait_variance = domesticated_trait_variance,
upper_bound = domesticated_upper_bound,
lower_bound = domesticated_lower_bound
))
return(results)
}
simulate <- function(time_steps, pest_pressure) {
population <- initialize_population()
results <- data.table(
time = integer(),
group = character(),
count = integer(),
avg_trait = numeric(),
trait_variance = numeric(),
upper_bound = numeric(),
lower_bound = numeric()
)
for (t in 1:time_steps) {
population <- grow(population)
population <- reproduce(population)
population <- suffer_mortality(population, pest_pressure)
results <- plot_population(population, t, results)
}
ggplot(results, aes(x = time)) +
# Population size
geom_line(aes(y = count, color = group), linewidth = 1) +
# Average trait (scaled to align with population size)
geom_line(aes(y = avg_trait * max(results$count) / max(results$avg_trait),
color = group, linetype = group)) +
# Bounding region for variance (scaled to align with population size)
geom_ribbon(aes(ymin = lower_bound * max(results$count) / max(results$avg_trait),
ymax = upper_bound * max(results$count) / max(results$avg_trait),
fill = group), alpha = 0.1) +
scale_y_continuous(
name = "Population Size",
sec.axis = sec_axis(~ . * max(results$avg_trait) / max(results$count),
name = "Secondary Metabolite Expression (0-1)")
) +
scale_color_manual(
values = c("Wild Population" = "#27582b", "Domesticated Population" = "#59466a")  # Green and Purple
) +
scale_fill_manual(
values = c("Wild Population" = "#27582b", "Domesticated Population" = "#59466a")  # Green and Purple
) +
scale_linetype_manual(
values = c("Wild Population" = "dashed", "Domesticated Population" = "dashed")
) +
guides(
color = guide_legend(order = 1, title = "Population Size"),
fill = guide_legend(order = 2, title = "Trait Expression"),
linetype = guide_legend(order = 2, title = "Trait Expression")
) +
labs(
title = sprintf("Time Steps: %d, Pest Pressure: %.2f", time_steps, pest_pressure),
x = "Time Steps",
color = "Group",
fill = "Group",
linetype = "Group"
) +
theme_minimal()
}
# Run simulation for single instance to test
result_plot <- simulate(time_steps = 100, pest_pressure = 0.8)
result_plot
# Run simulation for single instance to test
result_plot <- simulate(time_steps = 100, pest_pressure = 0.3)
result_plot
# Run simulation for single instance to test
result_plot <- simulate(time_steps = 100, pest_pressure = 0.3)
result_plot
# Run simulation for single instance to test
result_plot <- simulate(time_steps = 100, pest_pressure = 0.2)
result_plot
# Reproduce function
reproduce <- function(population) {
# Calculate number of offspring for each individual plant
reproduction_prob <- population$reproduction_rate * 0.1
num_offspring <- floor(reproduction_prob) # Ensure integer
# Create new plants based on reproduction probability
new_plants <- population[rep(1:.N, num_offspring)]
if (nrow(new_plants) > 0) {
new_plants[, size := 1]
new_plants[, growth_rate := 1 - trait]
new_plants[, reproduction_rate := 1 - trait]
new_plants[, resistance := trait]
population <- rbind(population, new_plants)
}
return(population)
}
# Run simulation for single instance to test
result_plot <- simulate(time_steps = 100, pest_pressure = 0.2)
result_plot
# mortality function
suffer_mortality <- function(population, pest_pressure) {
mortality_prob <- pest_pressure * (1 - population$resistance) * 0.05
survivors <- population[runif(.N) >= mortality_prob]
return(survivors)
}
# Run simulation for single instance to test
result_plot <- simulate(time_steps = 100, pest_pressure = 0.2)
result_plot
# Create wild population
wild_population <- data.table(
trait = rnorm(num_wild_population, mean = 0.6, sd = 0.3),  # Gaussian distribution
growth_rate = NA,
reproduction_rate = NA,
resistance = NA,
size = 1,
group = "Wild Population"
)
# Initialize plant population
initialize_population <- function() {
# Create wild population
wild_population <- data.table(
trait = rnorm(num_wild_population, mean = 0.6, sd = 0.3),  # Gaussian distribution
growth_rate = NA,
reproduction_rate = NA,
resistance = NA,
size = 1,
group = "Wild Population"
)
# Ensure trait value within [0, 1] for wild population
wild_population[trait < 0, trait := 0]
wild_population[trait > 1, trait := 1]
# Create domesticated population
domesticated_population <- data.table(
trait = rnorm(num_domesticated_population, mean = 0.4, sd = 0.02),  # Narrow Gaussian distribution
growth_rate = NA,
reproduction_rate = NA,
resistance = NA,
size = 1,
group = "Domesticated Population"
)
# Ensure trait value within [0, 1] for domesticated population
domesticated_population[trait < 0, trait := 0]
domesticated_population[trait > 1, trait := 1]
# Combine populations
population <- rbind(wild_population, domesticated_population)
# Initialize plant properties
population[, growth_rate := 1 - trait]
population[, reproduction_rate := 1 - trait]
population[, resistance := trait]
return(population)
}
# Run simulation for single instance to test
result_plot <- simulate(time_steps = 100, pest_pressure = 0.2)
result_plot
# Reproduce function
reproduce <- function(population) {
# Calculate number of offspring for each individual plant
reproduction_prob <- population$reproduction_rate * 0.2
num_offspring <- floor(reproduction_prob) # Ensure integer
# Create new plants based on reproduction probability
new_plants <- population[rep(1:.N, num_offspring)]
if (nrow(new_plants) > 0) {
new_plants[, size := 1]
new_plants[, growth_rate := 1 - trait]
new_plants[, reproduction_rate := 1 - trait]
new_plants[, resistance := trait]
population <- rbind(population, new_plants)
}
return(population)
}
# Run simulation for single instance to test
result_plot <- simulate(time_steps = 100, pest_pressure = 0.2)
result_plot
#' Check and install required packages
install_required_packages <- function() {
# Check and install devtools if not present
if (!requireNamespace("devtools", quietly = TRUE)) {
message("Installing devtools package...")
install.packages("devtools")
}
# Check and install rvle if not present
if (!requireNamespace("rvle", quietly = TRUE)) {
message("Installing rvle package...")
devtools::install_github("picasa/rvle")
}
# Check and install rsunflo if not present
if (!requireNamespace("rsunflo", quietly = TRUE)) {
message("Installing rsunflo package...")
devtools::install_github("picasa/rsunflo")
}
# Load required packages
library(rvle)
library(rsunflo)
library(tidyverse)
# Verify VLE installation
if (!"Rvle" %in% class(rvle::get_vle())) {
stop("VLE simulation platform not installed. Please install from VLE project website.")
}
message("All required packages installed and loaded successfully.")
}
#' Check for SUNFLO model file
check_sunflo_model <- function() {
if (!file.exists("sunflo_web.vpz")) {
stop("SUNFLO model file 'sunflo_web.vpz' not found. Please download from RECORD project.")
}
message("SUNFLO model file found.")
}
#' Initialize SUNFLO model
#' @param model_path Path to the SUNFLO model file
#' @return Rvle object
initialize_sunflo <- function(model_path = "sunflo_web.vpz") {
tryCatch({
sunflo <- new("Rvle", file = model_path, pkg = "sunflo")
message("SUNFLO model initialized successfully.")
return(sunflo)
}, error = function(e) {
stop("Failed to initialize SUNFLO model: ", e$message)
})
}
#' Run single simulation
#' @param design Design of experiments
#' @param unit_id Unit ID to simulate
#' @return Simulation results
run_single_simulation <- function(design, unit_id) {
tryCatch({
results <- design %>%
play(unit = unit_id) %>%
shape(view = "timed")
return(results)
}, error = function(e) {
warning("Simulation failed for unit ", unit_id, ": ", e$message)
return(NULL)
})
}
#' Run multiple simulations in parallel
#' @param design Design of experiments
#' @param n_cores Number of CPU cores to use (default: 4)
#' @return Data frame with simulation results
run_parallel_simulations <- function(design, n_cores = 4) {
if (!requireNamespace("doMC", quietly = TRUE)) {
install.packages("doMC")
}
library(doMC)
registerDoMC(cores = n_cores)
list_simulation <- design %>% select(id)
output <- list_simulation %>%
plyr::mdply(possibly(run_single_simulation, NULL), design = design) %>%
as_tibble()
return(output)
}
#' Calculate crop performance indicators
#' @param simulation_results Simulation results data frame
#' @return Data frame with performance indicators
calculate_indicators <- function(simulation_results) {
output_indicators <- simulation_results %>%
group_by(id) %>%
do(indicate(.)) %>%
ungroup()
return(output_indicators)
}
#' Plot simulation results
#' @param results Simulation results
#' @param indicator Indicator to plot
plot_results <- function(results, indicator) {
ggplot(results, aes(x = id, y = !!sym(indicator))) +
geom_point() +
geom_line() +
theme_minimal() +
labs(title = paste("SUNFLO Simulation Results -", indicator),
x = "Simulation ID",
y = indicator)
}
main <- function() {
# Install and check requirements
install_required_packages()
check_sunflo_model()
# Load design of experiments
design <- readRDS("inst/doc/files/design.rds")
# Initialize model
sunflo <- initialize_sunflo()
# Run default simulation
default_results <- sunflo %>%
run() %>%
results() %>%
shape(view = "timed")
# Display default results
display(default_results)
# Run parallel simulations
simulation_results <- run_parallel_simulations(design)
# Calculate indicators
performance_indicators <- calculate_indicators(simulation_results)
# Plot results (example with yield indicator)
if ("yield" %in% names(performance_indicators)) {
p <- plot_results(performance_indicators, "yield")
print(p)
}
return(list(
default_results = default_results,
simulation_results = simulation_results,
performance_indicators = performance_indicators
))
}
# Execute main function if script is run directly
if (!interactive()) {
results <- main()
}
interactive
# Execute main function if script is run directly
if (!interactive()) {
results <- main()
}
library(rvle)
library(rsunflo)
